package.preload["library.enigma_string"] = package.preload["library.enigma_string"] or function()

    local enigma_string = {}
    local starts_with_font_command = function(string)
        local text_cmds = {"^font", "^Font", "^fontMus", "^fontTxt", "^fontNum", "^size", "^nfx"}
        for _, text_cmd in ipairs(text_cmds) do
            if string:StartsWith(text_cmd) then
                return true
            end
        end
        return false
    end


    function enigma_string.trim_first_enigma_font_tags(string)
        local font_info = finale.FCFontInfo()
        local found_tag = false
        while true do
            if not starts_with_font_command(string) then
                break
            end
            local end_of_tag = string:FindFirst(")")
            if end_of_tag < 0 then
                break
            end
            local font_tag = finale.FCString()
            if string:SplitAt(end_of_tag, font_tag, nil, true) then
                font_info:ParseEnigmaCommand(font_tag)
            end
            string:DeleteCharactersAt(0, end_of_tag + 1)
            found_tag = true
        end
        if found_tag then
            return font_info
        end
        return nil
    end

    function enigma_string.change_first_string_font(string, font_info)
        local final_text = font_info:CreateEnigmaString(nil)
        local current_font_info = enigma_string.trim_first_enigma_font_tags(string)
        if (current_font_info == nil) or not font_info:IsIdenticalTo(current_font_info) then
            final_text:AppendString(string)
            string:SetString(final_text)
            return true
        end
        return false
    end

    function enigma_string.change_first_text_block_font(text_block, font_info)
        local new_text = text_block:CreateRawTextString()
        if enigma_string.change_first_string_font(new_text, font_info) then
            text_block:SaveRawTextString(new_text)
            return true
        end
        return false
    end



    function enigma_string.change_string_font(string, font_info)
        local final_text = font_info:CreateEnigmaString(nil)
        string:TrimEnigmaFontTags()
        final_text:AppendString(string)
        string:SetString(final_text)
    end

    function enigma_string.change_text_block_font(text_block, font_info)
        local new_text = text_block:CreateRawTextString()
        enigma_string.change_string_font(new_text, font_info)
        text_block:SaveRawTextString(new_text)
    end

    function enigma_string.remove_inserts(fcstring, replace_with_generic, convert_tags_to_literals)
        local text_cmds = {
            "^arranger", "^composer", "^copyright", "^date", "^description", "^fdate", "^filename", "^lyricist", "^page",
            "^partname", "^perftime", "^subtitle", "^time", "^title", "^totpages", "^value", "^control", "^pass"
        }
        local lua_string = fcstring.LuaString
        for _, text_cmd in ipairs(text_cmds) do
            local starts_at = string.find(lua_string, text_cmd, 1, true)
            while starts_at ~= nil do
                local replace_with = ""
                if replace_with_generic then
                    if convert_tags_to_literals then
                        replace_with = "^" .. text_cmd
                    else
                        replace_with = "[" .. string.sub(text_cmd, 2) .. "]"
                    end
                end
                local next_at = starts_at + #text_cmd
                if not replace_with_generic or not convert_tags_to_literals then
                    next_at = string.find(lua_string, ")", next_at, true) + 1 or starts_at
                end
                lua_string = string.sub(lua_string, 1, starts_at - 1) .. replace_with .. string.sub(lua_string, next_at)
                starts_at = string.find(lua_string, text_cmd, starts_at + #replace_with, true)
            end
        end
        fcstring.LuaString = lua_string
    end

    function enigma_string.expand_value_tag(fcstring, value_num)
        value_num = math.floor(value_num + 0.5)
        fcstring.LuaString = fcstring.LuaString:gsub("%^value%(%)", tostring(value_num))
    end

    function enigma_string.calc_text_advance_width(inp_string)
        local accumulated_string = ""
        local accumulated_width = 0
        local enigma_strings = inp_string:CreateEnigmaStrings(true)
        for str in each(enigma_strings) do
            accumulated_string = accumulated_string .. str.LuaString
            if string.sub(str.LuaString, 1, 1) ~= "^" then
                local fcstring = finale.FCString()
                local text_met = finale.FCTextMetrics()
                fcstring.LuaString = accumulated_string
                local font_info = fcstring:CreateLastFontInfo()
                fcstring.LuaString = str.LuaString
                fcstring:TrimEnigmaTags()
                text_met:LoadString(fcstring, font_info, 100)
                accumulated_width = accumulated_width + text_met:GetAdvanceWidthEVPUs()
            end
        end
        return accumulated_width
    end
    return enigma_string
end
function plugindef()


    finaleplugin.Author = "Robert Patterson"
    finaleplugin.Copyright = "CC0 https://creativecommons.org/publicdomain/zero/1.0/"
    finaleplugin.Version = "1.0.1"
    finaleplugin.Date = "June 12, 2020"
    finaleplugin.CategoryTags = "Lyric"
    finaleplugin.HashURL = "https://raw.githubusercontent.com/finale-lua/lua-scripts/master/hash/prefs_reset_lyrics_fonts.hash"
    return "Reset Lyrics Fonts", "Reset Lyrics Fonts", "Reset lyrics to document\'s default font settings."
end
local enigma_string = require("library.enigma_string")
function prefs_reset_lyrics_block_font(lyrics_block, pref_id)
    local font_info = finale.FCFontInfo()
    font_info:LoadFontPrefs(pref_id)
    if lyrics_block:LoadFirst() then



        local next_id = lyrics_block.ItemNo
        local loaded_next = true
        while loaded_next do
            local lyric_text = lyrics_block:CreateString()


            if enigma_string.change_first_string_font(lyric_text, font_info) then
                lyrics_block:SetText(lyric_text)
                lyrics_block:Save()
            end
            next_id = next_id + 1
            while not lyrics_block:Load(next_id) do
                next_id = next_id + 1
                if (next_id > 10000) then
                    loaded_next = false
                    break
                end
            end
        end
    end
end
function prefs_reset_lyrics_fonts()
    prefs_reset_lyrics_block_font(finale.FCVerseLyricsText(), finale.FONTPREF_LYRICSVERSE)
    prefs_reset_lyrics_block_font(finale.FCChorusLyricsText(), finale.FONTPREF_LYRICSCHORUS)
    prefs_reset_lyrics_block_font(finale.FCSectionLyricsText(), finale.FONTPREF_LYRICSSECTION)
end
prefs_reset_lyrics_fonts()
